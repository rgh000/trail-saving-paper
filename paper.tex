\documentclass[runningheads]{llncs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
%\usepackage[noend]{algcompatible}
%\usepackage[ruled,linesnumbered,noend,oldcommands]{algorithm2e}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[table]{xcolor}
\usepackage{theorem}
\usepackage{float}

\algrenewcommand\algorithmicprocedure{}
\algrenewcommand\algorithmicthen{}
\algrenewcommand\algorithmicdo{}
\definecolor{linen}{rgb}{0.98, 0.94, 0.9}
\definecolor{lightcyan}{rgb}{0.88, 1.0, 1.0}

\lstset { %
  language=C++,
  % backgroundcolor=\color{black!5}, % set backgroundcolor
  basicstyle=\footnotesize,% basic font setting
}

\renewcommand{\note}[1]{{\color{red}{#1}}}
\newcommand{\fs}[1]{\fontsize{#1}{#1}\selectfont}
\newcommand{\fss}[2]{\fontsize{#1}{#2}\selectfont}
\newcommand{\sat}{SAT\xspace}
\newcommand{\trail}{\ensuremath{\mathcal{T}}}
\newcommand{\trailIdxT}[2]{\ensuremath{\iota_{#1}(#2)}}
\newcommand{\trailIdx}[1]{\ensuremath{\iota(#1)}}
\newcommand{\range}[2]{#1\ldots#2}
\newcommand{\dlevel}[1]{\ensuremath{\mathit{decLvl}(#1)}}
\newcommand{\dlevels}{\ensuremath{\mathit{decLvls}}}
\newcommand{\var}{\text{var}}
\newcommand{\true}{\textsc{true}\xspace}
\newcommand{\false}{\textsc{false}\xspace}
\newcommand{\reason}[1]{\ensuremath{\mathit{reason}(#1)}}
\newcommand{\reasonsave}[1]{\ensuremath{\mathit{reason_{\mathit{save}}(#1)}}}
\newcommand{\litsave}{\ensuremath{\mathit{l_{\mathit{save}}}}}
\newcommand{\formula}{\ensuremath{\mathcal{F}}}
\renewcommand{\implies}{\rightarrow}
\newcommand{\uipcls}{C_{\textit{1-UIP}}}
\newcommand{\deepestLvl}{L_{\textit{deep}}}
\newcommand{\deepestLit}{\ell_{\textit{deep}}}
\newcommand{\btL}{L_{\textit{back}}}
\newcommand{\cbt}{C-bt\xspace}
\newcommand{\trailsave}{\trail_{\mathit{save}}}
\newcommand{\bt}{\textsc{backtrack}\xspace}
\newcommand{\ust}{\textsc{useSavedTrail}\xspace}

\newtheorem{Obs}{Observation}
\newtheorem{Cor}{Corollary}
\newtheorem{defn}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{ex}{Example}
\newcommand{\whitebox}{\raisebox{.5ex}{\fbox{\hspace*{.2ex}}}}

\title{Trail Saving on Backtrack}
\author{Randy Hickey \and Fahiem Bacchus}
\institute{Department of Computer Science, University of Toronto, Canada\\
  \email{rhickey@cs.toronto.edu, fbacchus@cs.toronto.edu}}

\begin{document}
\maketitle
\begin{abstract}
    A CDCL \sat solver can backtrack a large distance when it learns a
    new clause, e.g, when the new learnt clause is a unit clause the
    solver has to backtrack to level zero. When the length of the
    backtrack is large, the solver can end up reproducing many of the
    same decisions and propagations when it redescends the search
    tree. Different techniques have been proposed to reduce this
    potential redundancy, e.g., partial/chronological backtracking and
    trail saving on restarts. In this paper we present a new trail
    saving technique that is not restricted to restarts, unlike prior
    trail saving methods. Our technique makes a copy of the part of
    the trail that is backtracked over. This saved copy can then be
    used to improve the efficiency of the solver's subsequent
    redescent. Furthermore, the saved trail also provides the solver
    with the ability to look ahead along the previous trail which can
    be exploited to improve its efficiency. Our new trail saving
    technique offers different tradeoffs in comparison with
    chronological backtracking and often yields superior performance.
    We also show that our technique is able to improve the performance
    of state-of-the-art solvers.
\end{abstract}

\section{Introduction}
The vast majority of modern SAT solvers that are used to solve
real-world problems are based on the conflict-driven clause learning
(CDCL) algorithm. In a CDCL SAT solver, backtracking occurs after
every conflict, where all literals from one or more decision levels
become unassigned before the solver resumes making decisions and
performing unit propagations. Traditionally, CDCL solvers would
backtrack to the conflict level, which is the second highest decision
level remaining in the conflict clause after conflict analysis has
resolved away all but one literal from the current decision level
\cite{DBLP:conf/dac/MoskewiczMZZM01}. Recently, however, it has been
shown that partial backtracking \cite{DBLP:conf/lpar/JiangZ13} or
chronological backtracking, \cbt, (i.e., backtracking only to the
previous level after conflict analysis)
\cite{DBLP:conf/sat/NadelR18,DBLP:conf/sat/MohleB19} can be effective
on many instances. Partial backtracking has been used in the solvers
that won the last two SAT competitions. Although chronological
backtracking breaks some of the conventional invariants of CDCL
solvers, it has been formalized and proven correct
\cite{DBLP:conf/sat/MohleB19} (also see related formalizations 
\cite{DBLP:journals/jacm/NieuwenhuisOT06,nadelPhD}).

The motivation for using \cbt is the observation that when a solver
backtracks across many levels, many of the literals that are
unassigned during the backtrack might be re-assigned again in roughly
the same order when the solver redescends. This observation was first
made in the context of restarts by van der Tak et
al. \cite{DBLP:journals/jsat/TakRH11}. Their technique backtracks to
the minimum change level, i.e., the first level at which the solver's
trail can change on redescent. However, their technique cannot be used
when backtracking from a conflict: the solver's trail is going to be
changed at the backtrack level so the minimum change level is the same
as the backtrack level. 

Chronological backtracking or partial backtracking instead allows a
reduction in the length of the backtrack by placing literals on the
trail out of decision level order. By reducing the length of the
backtrack the solver can keep more of its assignment trail
intact. This can save it from the work involved in reconstructing a
lot of its trail. Using \cbt is not a panacea however. Its application
must be limited for peak effectiveness. This indicates that it is
sometimes beneficial for the solver to backtrack fully and redo its
trail, even if this takes more work. We will expand on why this might
be the case below.

In this paper we present a new trail saving method whereby we save
the backtracked part of the solver's trail and attempt to use that
information to make the solver's redescent more efficient. Unlike
\cbt, our trail saving method preserves the traditional invariants of
the SAT solver and its basic version is very simple to implement. It
allows the search to retain complete control over the order of
decisions, but helps make propagation faster. We develop some
enhancements to make the idea more effective, and demonstrate
experimentally that it performs as well as and often better than
chronological backtracking. We also show that with our enhancements we
are able to improve the performance of state-of-the-art solvers.

\section{Background}
\label{sec:background}
\sat solvers determine the satisfiability of a propositional formula
$\formula$ expressed in Conjunctive Normal Form (CNF). $\formula$
contains a set of variables $V$. A literal is a variable $v\in V$ or
its negation $\lnot v$, and for a literal $l$ we let $\var(l)$ denote
its underlying variable. A CNF consists of a conjunction of clauses,
each of which is a disjunction of literals. We often view a clause as
being a set of literals and employ set notation, e.g., $\ell\in C$ and
$C'\subset C$. We will assume that the reader is familiar with the
basic operations of CDCL \sat solvers. A good source for this
background is \cite{DBLP:series/faia/SilvaLM09}.

\paragraph{Trails.}
CDCL \sat solvers maintain a trail which is the sequence of literals
that have currently been assigned \true by the solver. During its
operation a \sat solver will add newly assigned literals to the end of
the trail, and on backtrack remove literals from the end of the
trail. For convenience, we will regard \emph{literals as having been
  assigned \true if and only if they are on the trail}. So
removing/adding a literal to the trail is equivalent to
unassigning/assigning the literal $\true$.

A \sat solver's trail satisfies a number of conditions. However, in
this work we will need some additional flexibility in our definitions,
as we will sometimes be working with trails that would never be
constructed by a \sat solver. Hence, we define a \emph{trail} to be a
sequence of literals each of which is either a \emph{decision} literal
or an \emph{implied} literal, and each of which has a
\emph{reason}. These two types of literals are distinguished by their
\emph{reasons}. Decision literals $d$ have a null reason,
$\reason{d} = \varnothing$. Implied literals $l$ have as a reason a
clause of the formula $\formula$, $\reason{l} =
C\in\formula$. (The clause $\reason{l}$ can be a learnt clause that has been
added to $\formula$).

If literal $\ell$ is on the trail $\trail$ let
$\trailIdxT{\trail}{\ell}$ denote its index on the trail, i.e,
$\trail[\trailIdxT{\trail}{\ell}] = \ell$. If $x$ and $y$ are both on
the trail and $\trailIdxT{\trail}{x} < \trailIdxT{\trail}{y}$ we say
that \textit{$x$ appears before $y$ on the trail}. For convenience,
when the trail being discussed is clear from context we simply write
$\iota$ instead of $\iota_{\trail}$.

Each literal $\ell\in\trail$ has a decision level $\dlevel{\ell}$
which is equal to the number of decision literals appearing on the trail
up to and including $\ell$ ; hence, $\dlevel{d}=1$ for the first
decision literal $d\in\trail$. The set of literals on $\trail$ that
have the same decision level forms a \emph{contiguous}
subsequence\footnote{Our approach uses standard trails in which the
  decision levels are contiguous. Chronological backtracking
  \cite{DBLP:conf/lpar/JiangZ13,DBLP:conf/sat/NadelR18,DBLP:conf/sat/MohleB19}
  generates trails with non-contiguous decision levels} that starts
with a decision literal $d_i$ and ends just before the next decision
literal $d_{i+1}$. We will often need to refer to different decision
level subsequences of $\trail$. Hence, we let $\trail[[i]]$ denote the
subsequence of literals at decision level $i$; and let
$\trail[[\range{i}{j}]]$ denote the subsequence of literals at
decision levels $k$ for $i\leq k\leq j$. 
\begin{defn}
    A clause $C$ has \textbf{been made unit by $\trail$ implying $l$}
    when
    $l\in C \land \bigl(\forall x\in C. x\neq l \implies \lnot x \in
    \trail\bigr)$. That is, all literals in $C$ except $l$ must have
    been falsified by $\trail$
\end{defn}

Now we define the following properties that a trail $\trail$ can have.
\begin{description}
\item[non-contradictory:] A variable cannot appear in both polarities
    in the trail: $l\in \trail\implies \lnot l \not \in \trail$.
\item[non-redundant:] A literal can only appear once on $\trail$.
\item[reason-sound:] For each implied literal $l\in\trail$ we have
    that its reason clause $\reason{l}=C$ has been made unit by
    $\trail$ implying $l$, and for each $x\in C$ with $x\neq l$ we
    have that $\lnot x$ appears before $l$ on $\trail$:
    $\forall l\in\trail.\, \reason{l}\neq \varnothing \implies
    l\in\reason{l} \land \bigl(\forall x\in\reason{l}.\, x\neq l
    \implies \lnot x \in \trail \land \trailIdx{\lnot x} <
    \trailIdx{l}\bigr)$.
\item[propagation-complete:] Unit propagation has been run to
    completion at all decisions levels of $\trail$. This means that
    literals appear on $\trail$ at the first decision level they were
    unit implied. Formally, this can be captured by the condition:
    $\forall i \in \{\dlevel{l}\,|\,l\in \trail\}. \bigl(\exists
    C\in\formula. \mbox{$C$ is made unit by $\trail[[\range{0}{i}]]$
      implying $l$}\bigr) \implies l\in \trail[[\range{0}{i}]]$. Note
    that propagation completeness implies that
    $\reason{l}\neq \varnothing$ must contain at least one other
    literal $y\neq l$ with $\dlevel{y} = \dlevel{l}$.
\item[conflict-free:] No clause of $F$ is falsified by
    $\trail$. Clauses $C\in F$ falsified by $\trail$ are typically
    called \emph{conflicts}.
\end{description}

In CDCL solvers using standard conflict directed backtracking all
properties hold of the prefix of the solver's trail consisting of all
decisions levels but the deepest. The full trail might, however,
contain a conflict at its deepest level so is not necessarily conflict-
free. The full trail might also not be propagation-complete, as unit
propagation at the deepest level is typically terminated early if a
conflict is found. It can further be noted that the first four
properties imply that if a clause $C$ is falsified at decision level
$k$, then $C$ must contain at least two literals at level $k$
(otherwise $C$ would have become unit at a prior level and then
satisfied by making its last unfalsified literal \true).

\paragraph{Standard Backtracking.}
In CDCL \sat solving the solver extends its trail by adding new
decision literals followed by finding and adding all unit implied
literals arising from that new decision. This continues until it
reaches a decision level $\deepestLvl$ where a conflict $C$ is found.

In standard backtracking, the solver then constructs a new 1-UIP
clause by resolving away all but one literal at level $\deepestLvl$
from the conflict $C$ using the reason clauses of these literals. (As
noted above $C$ must contain at least two literals at level
$\deepestLvl$). Hence, the new clause $\uipcls$ will contain one
literal $\deepestLit$ at level $\deepestLvl$ and have all of its other
literals a levels less than $\deepestLvl$. The solver then backtracks
to $\btL$ the second deepest level in $\uipcls$. This involves
changing $\trail$ to its prefix $\trail[[\range{0}{\btL}]]$ (by our
convention all literals removed from $\trail$ are now unassigned). The
new clause $\uipcls$ is made unit by $\trail[[\range{0}{\btL}]]$
implying $\deepestLit$, so the solver then adds $\deepestLit$ to the
trail and executes another round of unit propagation at level $\btL$,
after which it continues by once again growing the trail with new
decisions and unit implied literals until a new conflict or a
satisfying assignment is found.

In standard backtracking, the difference between the backtrack level,
$\btL$ and the current deepest level $\deepestLvl$ can be very
large. During its new descent from $\btL$ the solver can reproduce a
large number of the same decisions and unit propagations, essentially
wasting work. This potential inefficiency has been noted in prior work
\cite{DBLP:journals/jsat/TakRH11,DBLP:conf/lpar/JiangZ13,DBLP:conf/sat/NadelR18,DBLP:conf/sat/MohleB19}.

In \cite{DBLP:journals/jsat/TakRH11} a technique for reducing the
length of the backtrack during restarts was presented. In restarts,
the solver backtracks to level $0$, and this technique involves
computing a new deeper backtrack level $M> 0$ for which it is known
that on redescent the first $M+1$ levels of the trail will be
unchanged (except perhaps for the ordering of the literals). This
technique removes the redundant work of reproducing the first $M$
trail levels. When backtracking from a conflict, however, the trail
will be changed at level $\btL$ ($\deepestLit$ will be newly inserted
at this level). Hence this technique cannot reduce the length of the
backtrack. In this paper we will show that although we have to
backtrack to $\btL$ we can make the subsequent redescent much more
efficient.

\paragraph{Chronological Backtracking.}
Chronological backtracking (\cbt) and partial backtracking in the
context of clause learning solvers are alternatives to standard
backtracking which allow the solver to execute a shorter
backtrack. That is, with these techniques the solver can avoid having
to go all the way back to the second deepest level in the learnt
clause, as in standard backtracking.

Formalisms for partial backtracking in clause learning solvers have
been presented in
\cite{DBLP:journals/jacm/NieuwenhuisOT06,nadelPhD}. In
\cite{DBLP:conf/lpar/JiangZ13} practical issues of implementation were
addressed, and experiments shown with a CDCL solver using partial
backtracking. In \cite{DBLP:conf/sat/NadelR18} improved and more
efficient implementation techniques were developed which allowed \cbt
to make improvements to state-of-the-art \sat solvers, and
\cite{DBLP:conf/sat/MohleB19} presented additional implementation
ideas and details along with correctness results for these methods.

The aim of partial backtracking is to reduce the redundant work that
might be done by the \sat solver on its redescent from the backtrack
level $\btL$. The technique allows the solver to backtrack to any
level $j$ in the range $\btL \leq j \leq \deepestLvl{-}1$ (where
$\deepestLvl$ is the level the conflict was discovered). Nadel and
Ryvchin \cite{DBLP:conf/sat/NadelR18} proposed to always backtrack
chronologically to $\deepestLvl{-}1$ while M{\"{o}}hle and Biere
\cite{DBLP:conf/sat/MohleB19} returned to the proposal of
\cite{DBLP:conf/lpar/JiangZ13} of flexibly backtracking to any level
in the allowed range. Note that the new learnt 1-UIP clause $\uipcls$
is made unit at every level in this range. So after backtracking to
level $j$ the newly implied literal $\deepestLit$ is added to the
trail with $\reason{\deepestLit}=\uipcls$, and $\dlevel{\deepestLit}$
is set to $\btL$ (the second deepest level in $\uipcls$).

This means that the decision levels on the trail are no longer
contiguous, as $\deepestLit$ has a different level than the other
literals at level $j$ (if $j\neq \btL$). This change has a number of
consequences for the \sat solver's operation, all of which were
described in \cite{DBLP:conf/lpar/JiangZ13}. M{\"{o}}hle and Biere
\cite{DBLP:conf/sat/MohleB19} showed that despite these consequences
partial backtracking can be made to preserve the soundness of a CDCL
solver.

\section{Chronological Backtracking Effects on Search}
In this paper we present a new technique that allows the \sat solver
to use standard backtracking, but also allows saving some redundant
work on its redescent.  Our method has more overhead than \cbt so the
first question that must be addressed is why not just use
chronological backtracking.

Although \cbt is able to avoid a lot of redundant work it also has
other effects on the \sat solver search. These effects are sometimes
detrimental to the solver's performance and so it is not always
beneficial to use \cbt. In fact, in both \cite{DBLP:conf/sat/NadelR18}
and \cite{DBLP:conf/sat/MohleB19} it was found that fairly limited
application of \cbt performed best. In \cite{DBLP:conf/sat/NadelR18}
\cbt was applied only when the length of the standard backtrack,
$\btL-\deepestLvl$ was greater than a given threshold $T$. In their
experiments they found that $T=100$ was the best value, i.e., \cbt is
done only on longer backtracks. In practice, this meant that \cbt was
relatively infrequent; in our measurements with their solver only
about 3\% of the solver backtracks were \cbt backtracks. In
\cite{DBLP:conf/sat/MohleB19} the value $T=100$ was also
applied. However, they introduced an additional technique to add some
applications of \cbt when the length of the backtrack is less than
$T$. This allowed \cite{DBLP:conf/sat/MohleB19} to utilize \cbt in
about 15\% of the backtracks.

Although it is difficult to know precisely why \cbt is not always
beneficial, we can identify some different ways in which \cbt can
affect the \sat solver's search. With standard backtracking the
literal $\deepestLit$ is placed on the trail at the end of $\btL$ and
then unit propagated. This could impact the trail in at least the
following ways. First, some literals might become unit at earlier
levels. This could include decision literals becoming forced which
might compress some decision levels together. Second, different
decisions might be made due to changes in the variable scores arising
from the newly learnt clause. And third, literals might be unit
implied with different reasons. \cbt can change all of these things,
each of which could have an impact on the future learnt clauses, and
thus on the solver's overall efficiency.

The second impact, changing variable scores, is partially addressed in
\cite{DBLP:conf/sat/MohleB19} who utilize the ideas of
\cite{DBLP:journals/jsat/TakRH11} to backtrack to a level where the
decisions would be unchanged. However, if the length of the backtrack
is greater than $100$ there could still be a divergence between the
variable decisions generated in standard backtracking and \cbt. An
argument is also given in \cite{DBLP:journals/jsat/TakRH11} that the
third impact, changing literal reasons, is not significant. However,
the experiments in \cite{DBLP:journals/jsat/TakRH11} were run before
good notions of clause quality were known
\cite{DBLP:conf/ijcai/AudemardS09}. Our empirical results indicate
that once clause quality is accounted for, changing the literal
reasons can have a significant impact.

The first impact is worth discussing since it was mentioned in
\cite{DBLP:conf/lpar/JiangZ13} but not in the subsequent works. This
is the issue of changing the decision levels of literals on the
trail. \cbt computes the decision level of each implied literal based
on the decision levels of the literals in its reason, but it does not
go backwards to change the decisions levels of literals earlier on the
trail.

\begin{example}
    For example, suppose that $(x, \lnot y)\in \formula$, the literal $x$
    is a decision literal on the trail with $\dlevel{x}=2$, and that
    the solver is currently at level $150$ where it encounters a
    conflict. If this conflict yields the unit clause $(y)$, standard
    backtracking would backtrack to level $0$, where $x$ would be
    implied. On redescent, $x$ would no longer form a new decision
    level and it would not appear in any new clauses (as it is
    entailed by $\formula$). \cbt, on the other hand, would backtrack
    to level $149$. On its trail $x$ would still be at level
    $2$. Until a backtrack past level $2$ occurs, learnt clauses might
    contain $\lnot x$, and thus have level $2$ added to their set of
    levels (potentially changing their LBD score). Only when backtrack
    past level $2$ occurs would $x$ be restored to its correct level
    $0$, and it would require inprocessing simplifications to remove $x$
    from the learnt clauses.
\end{example}

In sum, although these impacts of \cbt on the \sat solver's search
might or might not be harmful to the \sat solver, they do exist. In
fact, there are two pieces of evidence that these impacts can
sometimes be harmful. First, as mentioned above, previous work found
that it is best to only apply \cbt on large backtracks where it has
the potential to save the most work. If there were no harmful effects
it would always be effective to apply \cbt. And second, in our
empirical results below we show that our new trail saving technique,
which always uses standard backtracking, can often outperform
\cbt. Although our technique reduces the solver's work on redescent it
does not completely eliminate it like \cbt does. Hence its superior
performance can only occur if \cbt is sometimes harmful.

It is possible to combine \cbt with our trail saving technique to
reduce the amount of work required whenever the solver performs
non-chronological backtracking. However, \cbt greatly reduces the
potential savings that could be achieved by our method since most of
its non-chronological backtracks are relatively short (less than
threshold $T$ levels). In our preliminary experiments this combination
did not seem promising.

Nevertheless, there is good evidence that \cbt can improve \sat solver
performance.\footnote{\cbt can also be extremely useful in contexts
  where each descent can be very expensive, e.g., when doing theory
  propagation in SMT solving, or component analysis in \#\sat
  solving. In these cases, \cbt, by avoiding backtracking and
  subsequent redescent, has considerable potential for improving
  solver performance.} Hence, it should be that it is better to
perform \cbt in some branches. Hence, an interesting direction for
future work would be to develop better heuristics about when to use
\cbt in a branch and when to use standard backtracking augmented by
our trail saving method.

\section{Trail Saving}
Our approach is to save the trail $\trail$ on backtrack, and to use
the saved trail $\trailsave$ when the solver redescends to improve the
efficiency of propagations without affecting the decisions the solver
wants to make. The saved trail $\trailsave$ also provides a secondary
``lookahead mechanism'' that the \sat solver can exploit as it
redescends.

Suppose that the solver is at $\deepestLvl$ where it has encountered a
conflict. From the 1-UIP clause it learns, $\uipcls$, it now has to
backtrack to $\btL$. This is accomplished by calling
\textsc{backtrack($\btL$)}, shown in Figure~\ref{fig:trailUse}, which
saves the backtracked portion of the trail.

Note that \bt does not save the deepest level of $\trail$. The full
$\trail$ contains a conflict (at its deepest level). Hence the solver
will never reproduce all the same levels, and it would be useless to
save all of them. Note also that in addition to saving the literals in
$\trailsave$ we also save the clause reason of the unit implied
literals in a separate $\mathit{reason_{save}}$ vector. Finally, we
see that after backtrack the first literal on $\trailsave$ is a
decision literal: it is the first literal of $\trail$ at decision
level $\btL+1$. Literals will be removed from $\trailsave$ during its
use, but always in units of complete decision levels. So
$\trailsave[0]$ will always be a (previous) decision literal.

After backtrack the solver will add $\deepestLit$ to the end of the
updated $\trail$ with $\reason{\deepestLit}$ $\mbox{}=\uipcls$ and
then invoke unit propagation. $\trailsave$ is exploited during
propagation by the version of \textsc{propagate} shown in
Figure~\ref{fig:trailUse}, which will initially be invoked with the
argument $\trailIdx{\deepestLit}$ (i.e., the trail index of the newly
added implicant). The saved trail will be continually consulted during the
solver's descent whenever unit propagation is performed. When
backtrack occurs $\trailsave$ will be overwritten to store the new
backtracked portion of $\trail$.

\begin{figure}[!t]
\begin{algorithmic}[1]
    \Procedure{backtrack}{$\btL$}
    \State $\forall \ell\in\trail[[\range{\btL{+}1}{\deepestLvl{-}1}]]$ $\reasonsave{\ell} = \reason{\ell}$
    \State $\trailsave = \trail[[\range{\btL{+}1}{\deepestLvl{-}1}]]$\label{ln:btsave}
    \State $\trail = \trail[[\range{0}{\btL}]]$
    \EndProcedure
\end{algorithmic}

\begin{algorithmic}[1]
    \Procedure{propagate}{idx}
    \While{idx $\mbox{} < \trail.\mathrm{size}$()}
        \State $c\gets\mbox{}$ \ust()
        \If{($c\neq \varnothing$)} \textbf{return} $c$ \Comment{Found conflict from $\trailsave$}
        \EndIf
        \State $\ell \gets \trail[idx]$
        \For{each clause $c\in$ watchlist($\lnot \ell$)}
            \If{($c$ is unit implying $x$)}
                 \State $\trail.\mathrm{addToEnd}(x)$; \; $\reason{x} \gets c$            
            \ElsIf{($c$ is falsified)}\:
                 \textbf{return} $c$ \Comment{Found conflict from unit prop.}
            \Else\:
                 Update $c$'s watches.
            \EndIf
        \EndFor
        \State $idx$++
    \EndWhile
    \EndProcedure
    \Statex
    \Procedure{useSavedTrail}{\mbox{}}
    \State $idx\gets 0$; $c\gets \varnothing$
    \For{( ; $idx < \trailsave.\mathrm{size}()$; $idx$++)}
        \State $\litsave\gets \trailsave[idx]$
        \If{($\reasonsave{\litsave} = \varnothing$)} \Comment{Decision on $\trailsave$}
            \If{($\litsave\in\trail$)}\: \textbf{continue} \Comment{\true in solver, we can use its implied lits}
            \Else{}\: \textbf{break} \Comment{Only solver can set decisions, so we stop here}\label{ln:decnottrue}
            \EndIf
        \Else{} \Comment{Implied Literal on $\trailsave$}
             \If{($\litsave \in \trail$)}\: \textbf{continue}  \Comment{ignore redundant lits}\label{ln:skip}
             \ElsIf{($\lnot \litsave \in \trail$)} 
                \Comment{contradiction, return conflict and reset $idx$}\label{ln:conflict}
                 \State $c\gets\reasonsave{\litsave}$; $idx\gets 0$; \textbf{break}
             \Else{} \Comment{unset in solver, add to solver's trail}
                  \State $\trail.\mathrm{addToEnd(\litsave)}$\label{ln:addToTrail}
                  \State $\reason{\litsave}\gets \reasonsave{\litsave}$\label{ln:addToTrailNext}
              \EndIf
        \EndIf
    \EndFor
    \For{($i \gets 0$; $i < idx$; $i$++)} \Comment{$\trailsave$ is unchanged when $idx=0$}
        \State $\trailsave.\mathrm{removeFront()}$\label{ln:popfront}
    \EndFor
    \State \textbf{return} $c$
    \EndProcedure
\end{algorithmic}

\caption{Using $\trailsave$ in unit propagation and conflict
  detection} \label{fig:trailUse}
\end{figure}

$\trailsave$ is consulted in the procedure $\ust$
(Figure~\ref{fig:trailUse}). This procedure tries to add saved implied
literals and their reasons to the solver's trail, when these
implications are valid. We will show below that those implications
that are added are in fact valid. We do not interfere with the
solver's variable decisions. Instead we opportunistically test to see
if literals implied on $\trailsave$ are valid implications for the
solver given the solver's current decisions.

$\trailsave[0]$ is always a (previous) decision literal $d$ with
$\reasonsave{d}=\varnothing$. Note that, since new literals (e.g.,
$\deepestLit$) have been added to $\trail$, $d$ might now be an
implied literal on $\trail$ (i.e., $\reason{d}\neq\varnothing$) even
though before the backtrack it was previously a decision (i.e.,
$\reasonsave{d}=\varnothing$). If $d$ has not been assigned $\true$ by
the solver (i.e., $\lnot d \in \trail$), we cannot add any implied
literals below it on $\trailsave$ to $\trail$ as these implied
literals depend on $d$ being assigned $\true$. In this case we stop
looking for more literals to add to $\trail$
(line~\ref{ln:decnottrue}).

On the other hand if $d$ has been made \true by the solver we can
continue to add all of the implied literals below it (up to but not
including the next decision literal on $\trailsave$) to $\trail$
(line~\ref{ln:addToTrail}), reusing their saved reasons. Any literals
that have already been made true by the solver can be skipped
(line~\ref{ln:skip}). Finally, if we encounter a literal that has
already been falsified by the solver, then its saved reason clause
must be falsified by the solver and we can return it as a conflict
(line~\ref{ln:conflict}). If a conflict is encountered we leave
$\trailsave$ unchanged by resetting $idx$ to zero. Otherwise, $idx$
will be the number of literals at the front of $\trailsave$ that have
been moved to $\trail$ (or skipped over since they are already on
$\trail$). We then remove the first $idx$ literals from $\trailsave$
(line~\ref{ln:popfront}), and return the conflict (equal to
$\varnothing$ if no conflict was found).

\begin{figure}[!t]
\begin{tabular}{l
  >{\raggedleft}p{4.75ex}>{\raggedleft}p{4.75ex}>{\raggedleft}p{4.75ex}>{\raggedleft}p{4.75ex}
  >{\raggedleft}p{4.75ex}>{\raggedleft}p{4.75ex}>{\raggedleft}p{4.75ex}>{\raggedleft}p{4.75ex}
  >{\raggedleft}p{4.75ex}>{\raggedleft}p{4.75ex}>{\raggedleft}p{4.75ex}>{\raggedleft}p{4.75ex}
  >{\raggedleft}p{4.75ex}>{\raggedleft}p{4.75ex}}
      $\trail$ 
      & $l_1^{1*}$ & $l_2^1$ & $l_3^{2*}$ & $l_4^2$
      & $l_5^{3*}$ & $l_6^3$ & $l_7^{4*}$ & $l_8^4$
      & $l_9^{5*}$ & $l_{10}^5$ & $l_{11}^5$ & $l_{12}^{6*}$
      & $l_{13}^6$ & $l_{14}^6$  \tabularnewline
     $\trailsave$
      &  &  &  & 
      &  &  &  &  
      &  &  &  &  
      &  & \tabularnewline
      \rowcolor{linen}
      \multicolumn{15}{l}{1-UIP ($\lnot l_1$, $\lnot l_3$, $\lnot l_{12}$) and backtrack 2 ($\btL$)}\tabularnewline
      $\trail$ 
      & $l_1^{1*}$ & $l_2^1$ & $l_3^{2*}$ & $l_4^2$
      &         &       &         &      
      &         &       &         &           
      &         &         \tabularnewline
      $\trailsave$
      &         &       &         &                     
      & $l_5^*$ & $l_6$ & $l_7^*$ & $l_8$
      & $l_9^*$ & $l_{10}$ & $l_{11}$ & 
      &         & 
      \tabularnewline
      \rowcolor{linen}
      \multicolumn{15}{l}{Unit Prop $\lnot l_{12}$ ($\deepestLit$), $\trailsave$ not yet helpful}\tabularnewline
      $\trail$ 
      & $l_1^{1*}$ & $l_2^1$ & $l_3^{2*}$ & $l_4^2$
      & $\smash{\lnot} l_{12}^2$  & $l_7^2$  & $l_9^2$    &      
      &         &       &         &           
      &         &         \tabularnewline
      $\trailsave$
      &         &       &         &                     
      & $l_5^*$ & $l_6$ & $l_7^*$ & $l_8$
      & $l_9^*$ & $l_{10}$ & $l_{11}$ &
      &         & 
      \tabularnewline
      \rowcolor{linen}
      \multicolumn{15}{l}{Make decision}\tabularnewline
      $\trail$ 
      & $l_1^{1*}$ & $l_2^1$ & $l_3^{2*}$ & $l_4^2$
      & $\smash{\lnot} l_{12}^2$  & $l_7^2$  & $l_9^2$ 
      & $l_5^{3*}$  &       &         &           
      &         &         \tabularnewline
      $\trailsave$
      &         &       &         &                     
      & $l_5^*$ & $l_6$ & $l_7^*$ & $l_8$
      & $l_9^*$ & $l_{10}$ & $l_{11}$ & 
      &         & 
      \tabularnewline
      \rowcolor{linen}
      \multicolumn{15}{l}{Now $\trailsave$ can be used to augment trail}\tabularnewline
      $\trail$ 
      & $l_1^{1*}$ & $l_2^1$ & $l_3^{2*}$ & $l_4^2$
      & $\lnot l_{12}^2$ \hfill & $l_7^2$  & $l_9^2$      
      & $l_5^{3*}$  & $l_6^{3}$  & $l_8^3$  & $l_{10}^3$          
      & $l_{11}^3$  &         \tabularnewline
      $\trailsave$
      &         &       &         &      
      &         &       &                              
      &         &       &         & 
      &         &       & 
    \end{tabular}
    \caption{Use of $\trailsave$ from
      Example~\ref{ex:trailsave}\label{fig:trailsave}. The literal's
      decision level is indicated in its superscript, and a $\mbox{}^*$
      superscript indicates that the literal is a decision.}
\end{figure}

\begin{example}
    \label{ex:trailsave} Figure~\ref{fig:trailsave} provides an
    example of how $\trailsave$ is used. Initially the literals $l_1$
    to $l_{14}$ are on the solver's $\trail$, and $\trailsave$ is
    empty. This is shown in the first two lines of the figure. In the
    figure the superscript on the literals indicates their decision
    level, and a superscripted $*$ indicates that the literal is a
    decision. Hence $l_1^{1*}$ indicates that $\dlevel{l_1}=1$ and
    that $l_1$ is a decision.

    Then a conflict is found at level $6$ and the 1-UIP clause
    $(\lnot l_1, \lnot l_3, \lnot l_{12})$ is learnt. Thus the solver
    will backtrack to level $2$, where it will add $\lnot l_{12}$ as a
    unit implicant. The next two lines show $\trail$ and $\trailsave$
    right after the backtrack to level $2$: the backtracked levels
    have been copied into $\trailsave$ omitting the conflict level $6$. 

    The new unit $\lnot l_{12}$ is now added to $\trail$ and unit
    propagation performed adding $l_7$ and $l_9$ to level 2. Since the
    first literal on $\trailsave$, $l_5$, has
    $\reasonsave{l_5}=\varnothing$ ($l_5$ was a decision on $\trail$
    at the time backtrack occurred) and is not yet $\true$,
    $\trailsave$ is not helpful at this stage. The status of $\trail$
    and $\trailsave$ at this point is shown in the figure.
    
    After unit propagation is finished the solver makes a new
    decision, which happens to be (but is not forced to be) $l_5$. Now
    $\trailsave$ can be used: $l_5$ is \true so it is removed, $l_6$
    is unassigned so it is added to $\trail$, $l_7$ is \true and so
    removed, $l_8$ is unassigned so it is added to $\trail$, $l_9$ is
    \true and removed, and finally $l_{10}$ and $l_{11}$ are
    unassigned and so are added to $\trail$. In this example,
    $\trailsave$ is emptied, and cannot contribute more to $\trail$.

    All of these units are added to $\trail$ before the solver starts
    to unit propagate $l_5$. Since, new literals have been added to
    $\trail$ before $l_5$ the solver must propagate $l_5$ and all of
    the literals that follow it before making its next
    decision. 
\end{example}

As noted in the previous example unit propagation has to be rerun on
all saved literals added to $\trail$ from $\trailsave$. Thus our
technique, unlike \cbt, does not completely remove the overhead of
reproducing the trail on the solver's redescent. Nevertheless, trail
saving improves the efficiency of this redescent in three different
ways. First, by adding more forced literals to the trail before
continuing propagating the next literal, propagation can potentially
gain a quadratic speedup
\cite{DBLP:conf/sat/HickeyB19,DBLP:journals/jair/Gent13}. Second,
propagation does not need to examine the reason clause of the added
literals. If these literals were not added by \ust, propagation would
have to traverse each of these reason clauses to determine that they
have in fact become unit. Third, when a conflict is returned by
\ust all further propagations can be halted. The added literals and
their reasons will be sufficient to perform clause learning from the
conflict returned by \ust. Since trail saving can sometimes save
hundreds or thousands of literals at a time these savings can in sum
be significant.

\subsection{Correctness}
Now we will prove that our use of $\trailsave$ preserves the \sat
solver's soundness. In particular, $\trailsave$ is only used in the
procedure \ust, in which it either adds new literals
to the solver's trail, or returns conflict clauses to the solver.
Hence, we only need to show that these new literals are in fact unit
implied and the conflicts are in fact falsified by the solver's trail.
\
Since both $\trail$ and $\trailsave$ are sequences of literals (with
associated reasons) we can consider their concatenation denoted as
$\trail + \trailsave$.
\begin{theorem}
    \label{thm:sound}
    If $\trail + \trailsave$ is \textbf{reason sound}
    (Section~\ref{sec:background}) then the following holds.  If the
    first $i$ literals on $\trailsave$ are all in $\trail$
    ($\forall j. 0\leq j< i. \trailsave[j]\in \trail$) and
    $\trailsave[i]=l$ is an implied literal with $\reasonsave{l} = C$,
    then $C$ has been made unit by $\trail$ implying $l$.
\end{theorem}
\noindent\emph{Proof:}
Since $\trail + \trailsave$ is reason sound, every literal in $C$
other than $l$ appears negated before $l$ in the sequence
$\trail + \trailsave$. Thus for $x\in C$ we have $\lnot x \in \trail$
or $\lnot x \in \trailsave[0]\ldots\trailsave[i-1]$. But in the later
case we also have $\lnot x \in \trail$. 
\whitebox

This theorem shows that \ust's processing is
sound. In this procedure, an implied literal from $\trailsave$ is added
to $\trail$ (line~\ref{ln:addToTrail}) only when all prior literals on
$\trailsave$ are already on $\trail$ (i.e., previously on $\trail$ or
already added to $\trail$). Thus each new addition is sound given the
inductive soundness of the previous additions, with the base case
covered by Theorem~\ref{thm:sound}. If $l$ is to be added, the theorem
shows that every other literal in $\reasonsave{l}$ has been falsified
by $\trail$. Hence if $l$ is also falsified by $\trail$ then
$\reasonsave{l}$ is a clause that is falsified by $\trail$, thus it is
a sound conflict for the solver.

Now we only have to show that $\trail+\trailsave$ is always
\textbf{reason sound} during the operation of the solver.
\begin{prop}
    \label{prop:sound}
    If $\trail+\trailsave$ is reason sound then $\trail'+\trailsave'$
    is reason sound in all of the following cases.
    \begin{enumerate}
    \item $\trailsave[0]\in \trail$, $\trail'=\trail$, and
        $\trailsave' = \trailsave.\mathrm{removeFront()}$.
    \item $\trail' = \trail+\trailsave[0]$ and
        $\trailsave' = \trailsave.\mathrm{removeFront()}$.
    \item $\trail' = \trail + \trail_{\mathit{new}}$ and
        $\trailsave' = \trailsave'$ and $\trail'$ is reason sound.
    \end{enumerate}
    4. We also have that $\trail$ is reason sound if $\trail$ was
    generated by the solver.
\end{prop}
\noindent \emph{Proof:} (1) $\trailsave[0]$ already appears earlier in
the $\trail$ so it can be removed without affecting the soundness of
any reason following it. (2) is obvious as the sequence is
unchanged. (3) the reasons in $\trail+\trail_{\mathit{new}}$ are sound
by assumption. Those in $\trailsave$ remain sound as they depend only
on the literals in $\trail$ and prior literals on $\trailsave$, both
of which are unchanged. (4) is obvious from the operation of unit
propagation in the solver.  \whitebox

\begin{theorem}
    \label{thm:rsound}
    $\trail+\trailsave$ is always reason sound during the operation of
    the solver.
\end{theorem}
\noindent \emph{Proof:} $\trailsave$ starts off being empty, so
$\trail+\trailsave = \trail$ is reason sound as it was generated by
the solver (4). In procedure \bt $\trail+\trailsave$ is
set to a trail that was previously generated by the solver (4). The solver
can add to $\trail$ by decisions and propagations without using
$\trailsave$. In this case $\trail' = \trail+\trail_{\mathit{new}}$,
and $\trail'$ is reason sound by (4), thus the new
$\trail'+\trailsave$ is reason sound by (3). Finally, in procedure
\ust either (a) literals at the front of
$\trailsave$ are discarded since they already appear on $\trail$, or
(b) literals are moved from $\trailsave$ to $\trail$. Under both of
these changes $\trail+\trailsave$ remains reason sound by (1) and (2).
\whitebox

\subsection{Enhancements}
We developed three enhancements of the base trail saving method
described above. In this section we present these enhancements.

\paragraph{Saving the trail over multiple backtracks.}
It can often be the case that when the solver finds a conflict and
backtracks to $\btL$ it might immediately find a another conflict at
$\btL$ causing a further backtrack. In the procedure \bt every
backtrack causes $\trailsave$ to be overwritten. Hence, in these cases
most of the trail will not be saved---only the portion from the last
backtrack. Our first extension addresses this potential issue and also
provides more general trail saving in other contexts as well.

This extension is simply to add the latest backtrack to the front of
$\trailsave$ leaving all of the previous contents of $\trailsave$
intact. Specifically, we replace line~\ref{ln:btsave} of \bt by the new line:\\
\hspace*{3em}3. \qquad $\trailsave = \trail[[\range{\btL{+}1}{\deepestLvl{-}1}]] + \trailsave$\\
It is not difficult to show that this change preserves soundness. Only
Theorem~\ref{thm:rsound} is potentially affected. However, we know
that $\trailsave$ is unchanged at the level at which a conflict
occurs: either the conflict is detected without consulting
$\trailsave$ or if the conflict comes from $\trailsave$ then \ust
leaves $\trailsave$ unchanged (line~\ref{ln:conflict}). Hence, at the
level before the conflict occurred we have inductively that
$\trail[[\range{0}{\deepestLvl{-}1}]]+\trailsave$ was reason sound,
and hence so is $\trail'+\trailsave'$ with
$\trail' = \trail[[\range{0}{\btL}]]$ and
$\trailsave' = \trail[[\range{\btL{+}1}{\deepestLvl{-}1}]] +
\trailsave$.

When adding to the front of $\trailsave$ in this manner $\trailsave$
can grow indefinitely. So we prune $\trailsave$ when it gets too large
by (a) removing $\trailsave[i]$ if $\trailsave[i] = \trailsave[j]$ for
some $j<i$ ($\trailsave[i]$ is redundant), and (b) removing the suffix
of $\trailsave$ starting at $\trailsave[i]$ when
$\trailsave[j] = \lnot \trailsave[i]$ for some $j<i$ ($\trailsave[i]$
will never be useful as its negation, $\trailsave[j]$, would have to be
added to $\trail$ first). In this way $\trailsave$ need never become
larger than the number of variables in $\formula$.

\paragraph{Lookahead for Conflicts.}
In \ust we stop adding literals from $\trailsave$ to $\trail$ once we
reach a decision literal $d$ on $\trailsave$ that is not yet on
$\trail$ (line~\ref{ln:decnottrue} of \ust). This is done so that the
solver has full control over variable decisions without interference
from the trail saving mechanism (unlike the case with \cbt). However,
another option would be to force the solver to use $d$ as its next
decision literal, which would then allow us to further add all of
$d$'s implied literals on $\trailsave$ onto $\trail$. This can be done
for the first $k$ decisions on $\trailsave$ for any $k$. But in
general, we do not want to remove the solver's autonomy by forcing it
to make potentially different decisions than it might have wanted to.

However, if there is a literal $l\in\trailsave$ for which
$\lnot l\in \trail$, we can observe that forcing the solver to make
all of the decisions of $\trailsave$ that lie above $l$ will
immediately generate a conflict in the solver: $\reasonsave{l}$ will
be falsified. In fact, in this situation we would not even need to
perform unit propagation over the literals added from $\trailsave$;
the literals and their reasons obtained from $\trailsave$ would be
sufficient to perform 1-UIP learning from $\reasonsave{l}$.

We experimented with this ``lookahead for conflicts'' idea using
various values of $k$. We found that $k=2$, i.e., forcing up to two
decisions from $\trailsave$ to be made by the solver if this yields a
conflict, often enhanced the solver's performance. Limiting the lookahead to
only one decision level of $\trailsave$ was not as good, and looking
ahead more than 2 decisions of $\trailsave$ also degraded
performance. This provides some evidence that taking too much
control away from the solver and forcing it to make too many decisions
from $\trailsave$ can lead to conflicts that are not as useful to the
solver.

\paragraph{Reason quality.}
The saved trail can be thought of as remembering the solver's recent
trajectory. Sometimes we want to follow the past trajectory, but
perhaps sometimes we do not. In particular, when adding literals from
$\trailsave{}$ to $\trail$ we can examine the quality of the saved
reasons to see if they are worth using. Once we encounter a literal
with a low quality saved reason we stop adding literals from
$\trailsave$ to the solver's trail. In particular, we can change
lines~\ref{ln:addToTrail}--\ref{ln:addToTrailNext} of \ust
to the following:\\[5pt]
\begin{tabular}[t]{l}
23.5 \qquad \textbf{if} (lowQuality($\reasonsave{\litsave}$)) \textbf{break}\\
24.  \qquad $\trail.\mathrm{addToEnd(\litsave)}$\\
25.  \qquad $\reason{\litsave}\gets \reasonsave{\litsave}$
\end{tabular}\\[5pt]

Note that the solver will still set the un-added literals as they are
unit implied by $\trail$, but it might be able to find better reasons
for these implicants. There is of course no guarantee that better
reasons will be found, but our empirical results show that sometimes
this does happen. We experimented with two quality metrics, clause
size and clause LBD, obtaining positive results with both. These
results also provides evidence against the argument given in
\cite{DBLP:journals/jsat/TakRH11} that changing literal reasons is not
impactful. With an appropriate clause quality metric the changing of literal
reasons can have an impact.

\section{Experiments and Results}
We implemented our techniques in two different SAT solvers, MapleSAT
and Cadical, \footnote{Our implementation is available at https://github.com/rgh000/cadical-trail.}
both of which have finished at or near the top of SAT
competitions for the past several years
\cite{Heule2018ProceedingsOS,Heule2019ProceedingsOS}. We then ran each
solver on the 800 total benchmark instances used in the main tracks of
the 2018 SAT Competition and 2019 SAT Race. The experiments were executed on a
cluster of 2.7 GHz Intel cores with 5000 seconds CPU time and 7 GB
memory limits for each instance. We chose not to output or verify the
proofs generated by any of the solvers. The Par-2 scores obtained and
total instances solved by each solver are reported in
Figures~\ref{fig:cadicalNew}, \ref{fig:cadicalOld}, and
\ref{fig:maple}. We also show the cactus plot of the new version of
cadical in Figure \ref{fig:cactus_cadical}.
%and MapleLCMDist in Figure \ref{fig:cactus_maple}.

In Figure~\ref{fig:cadicalNew} we used the newest version of cadical
(downloaded as of January 1, 2020) as the baseline solver, in
Figure~\ref{fig:cadicalOld} we used the version of cadical published
in \cite{DBLP:conf/sat/MohleB19} as the baseline, and in
Figure~\ref{fig:maple} we used MapleLCMDist \cite{DBLP:conf/ijcai/LuoLXML17,xiao2017maplelrb} as
the baseline. Each of the baselines were run with standard
non-chronological backtracking. We then refer to versions of each
solver with additional features implemented on top by adding
suffixes. "-chrono" refers to the solver with \cbt enabled (using the
solver's default settings), "-trail" refers to the baseline with plain
trail saving added (as described in Figure~\ref{fig:trailUse}),
"-trail-multipleBT" refers to the baseline with trail saving plus the
first enhancement of saving over multiple backtracks,
"-trail-multipleBT-lookahead" also adds the enhancement of lookahead
for conflicts by 2 decision levels, and
"-trail-multipleBT-lookahead-reason" also adds the final enhancement
to cease trail saving once a reason of "low quality" is reached. For
more details on the enhancements, please see section 4.2.



Interestingly, \cbt made the newest version of cadical perform worse
than the baseline (Figure~\ref{fig:cadicalNew}). This demonstrates
that \cbt is not always beneficial. Trail saving alone did not impact
the performance of this solver significantly, but adding all of the
enhancements on top of trail saving resulted in solving six more
instances and yielding a better Par-2 score than the baseline. The key
enhancement for this solver seemed to be the last one where we stop
using the saved trail once we detect a reason of "low quality". We
tried both clause size and lbd as the clause quality metric, and both
yielded a positive gain, with clause size being slightly more
effective.

\begin{figure}
\centering
    \begin{tabular}{|l|l|l|l|l|l|}
      \hline
      & Total & SAT & UNSAT & Avg. Par-2 \\ \hline
      cadical                  & 532          & 314 &  218  & 4025                             \\ \hline
      cadical-chrono          & 525          & 308 &  217  & 4086                             \\ \hline
      cadical-trail           & 529          & 310 &  \textbf{219}  & 4060                   \\ \hline
      cadical-trail-multipleBT & 530 & 313 & 217 & 3930 \\ \hline
      cadical-trail-multipleBT-lookahead & 531          & 313 &  218  & 4020                      \\ \hline
      cadical-trail-multipleBT-lookahead-reason & \textbf{538} & \textbf{319} & \textbf{219} & \textbf{3854} \\ \hline
    \end{tabular}
    \caption{Table of results for cadical, version pulled from github as of January 1, 2020.}
    \label{fig:cadicalNew}
\end{figure}

\begin{figure}\centering\includegraphics[scale=0.65]{figures/cactus_cadical_new.pdf}\caption{\small{Cactus plot for the newest version of cadical comparing standard non-chronological backtracking to \cbt and various configurations of trail saving. The first 400 problems were solved in less than 1200 seconds, so that part of the plot is truncated.}}\label{fig:cactus_cadical}\end{figure}

The version of cadical used in Figure~\ref{fig:cadicalOld} did show
benefits from \cbt in agreement with previously published results
\cite{DBLP:conf/sat/MohleB19}. Trail saving alone did not
significantly impact this solver, but adding all of the enhancements
on top of trail saving resulted in solving the same number of
instances as the solver with \cbt did, albeit with a slight increase
in the Par-2 score.

\begin{figure}
\centering
    \begin{tabular}{|l|l|l|l|l|l|}
      \hline
      & Total & SAT & UNSAT & Avg. Par-2 \\ \hline
      cadical                  & 492          & 289 &  203  & 4378                            \\ \hline
      cadical-chrono   & \textbf{498}  & \textbf{292} &  \textbf{206}  & \textbf{4300}      \\ \hline
      cadical-trail           & 493          & 290 &  203  & 4403                            \\ \hline
      cadical-trail-multipleBT-lookahead & 496  & \textbf{292} &  204  & 4356                    \\ \hline
      cadical-trail-multipleBT-lookahead-reason & \textbf{498} & \textbf{292} & \textbf{206} & 4351 \\ \hline
    \end{tabular}
    \caption{Table of results for cadical or "chrono", version published in \cite{DBLP:conf/sat/MohleB19}.}
    \label{fig:cadicalOld}
\end{figure}

MapleLCMDist (in Figure~\ref{fig:maple}) is another solver that
benefited from \cbt. In this solver trail saving alone solved two more
instances than the solver with \cbt did. Adding the first two
enhancements on top of trail saving resulted in solving only one more
instance but yielded a better Par-2 score than the solver with
\cbt. Adding the last enhancement of ceasing trail saving on a "low
quality" reason made the performance worse, whether clause size or lbd
was used as the clause quality metric. This suggests that the
enhancements to trail saving have different impacts on different
solvers.

\begin{figure}
\centering
    \begin{tabular}{|l|l|l|l|l|l|}
      \hline
      & Total & SAT & UNSAT & Avg. Par-2 \\ \hline
      maple           & 458          & 259 &  199  & 4746                             \\ \hline
      maple-chrono   & 470          & 271 &  199  & 4613                             \\ \hline
      maple-trail    & \textbf{472}          & 271 &  \textbf{201}  & 4618                \\ \hline
      maple-trail-multipleBT-lookahead & 471 & \textbf{272} &  199  & \textbf{4597}        \\ \hline
      maple-trail-multipleBT-lookahead-reason & 469 & 271 & 198 & 4633 \\ \hline
    \end{tabular}
    \caption{Table of results for MapleLCMDist.}
    \label{fig:maple}
\end{figure}

%\begin{figure}\centering\includegraphics[scale=0.65]{figures/cactus_maple_new.pdf}\caption{\small{Cactus plot for MapleLCMDist %comparing standard non-chronological backtracking to \cbt and various configurations of trail saving. The first 300 problems were %solved in less than 600 seconds, so that part of the plot is truncated.}}\label{fig:cactus_maple}\end{figure}

\section{Conclusion}
We have shown that our trail saving technique can speed up two
state-of-the-art \sat solvers, cadical and MapleSAT, as or more
effectively than chronological backtracking can. We also introduced three enhancements
one can implement when using a saved trail and demonstrated
experimentally that these enhancements can sometimes improve a
solver's performance by a significant amount. We have shown that trail
saving and all enhancements we proposed are sound.

There are many avenues that can be pursued in future work, such as
using the saved trail to help make inprocessing techniques faster or
using the saved trail to learn multiple clauses from a single
conflict. It is also possible to combine trail saving with
chronological backtracking, but it would require further work to determine
whether or not this would be useful and how to best approach it.

\bibliography{sat}{}
\bibliographystyle{splncs04}
\end{document}
